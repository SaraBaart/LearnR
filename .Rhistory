?lattice
knitr::opts_chunk$set(echo = TRUE)
library(lattice)
?lattice
library(foreign)
?foreign
knitr::opts_chunk$set(echo = TRUE)
wilcox.test(disp ~ am, data = data)
data(mtcars)
data <- mtcars
wilcox.test(disp ~ am, data = data)
#### ANOVA
When we want to compare a continuous variable in more than 2 groups, we can use an ANOVA. For this test, we assume that the continuous marker follows a normal distribution.
summary(data)
#### ANOVA
When we want to compare a continuous variable in more than 2 groups, we can use an ANOVA. For this test, we assume that the continuous marker follows a normal distribution.
summary(data)
table(data$gear)
boxplot(data$drat ~ data$gear)
aov1 <- aov(drat ~ gear, data = data)
summary(aov1)
```{r echo = T, eval=T}
TukeyHSD(aov1)
There appears to be a big difference, especially in "3".
str(data)
```{r echo = T, eval=T}
aov1 <- aov(drat ~ gear, data = data)
summary(aov1)
```
There appears to be a big difference, especially in "3".
str(data)
```{r echo = T, eval=T}
aov1 <- aov(drat ~ gear, data = data)
summary(aov1)
```
str(data)
str(data$gear)
data$gear.factor <- as.factor(data$gear)
str(data$gear.factor)
aov1 <- aov(drat ~ gear.factor, data = data)
summary(aov1)
TukeyHSD(aov1)
boxplot(data$disp ~ data$gear)
kruskal.test(disp ~ gear.factor, data = data)
?lattice
#### Correlations
Correlations are used for two continuous variables. We already
names(data)
plot()
&nbsp;
#### Correlations
Correlations are used for two continuous variables. We already
names(data)
plot(mpg, disp, data=data)
&nbsp;
plot(mpg, disp, data=data)
plot(mpg, disp, data=data)
plot(mpg ~ disp, data=data)
plot(hp ~ disp, data=data)
hist(data$ho)
hist(data$hp)
hist(data$drat)
hist(data$wt)
hist(data$qsec)
plot(qsec ~ disp, data=data)
cor.test(data$disp,data$mpg)
cor.test(data$disp, data$mpg, method = "spearman")
cor.test(mpg ~ disp, data = data, method = "spearman")
cor.test(mpg, disp, data = data, method = "spearman")
cor.test(data$mpg ~ data$disp, method = "spearman")
cor.test(data$disp, data$mpg, method = "spearman")
cor.test(data$disp, data$mpg, method = "spearman")
library(readxl)
library(lme4)
library(GLMMadaptive)
library(ggplot2)
library(dplyr)
VAS_data <- read_excel("Y:/Long/Gizal Nakshbandi/VAS_Totaal_final.xls")
# Use only the first half year (DAY < 169
VAS_data_6 <- VAS_data %>% filter(VAS_DAY < 169)
# Add LOES smoother
p <-  ggplot(data = VAS_data_6) +
geom_point(aes(x = VAS_DAY, y = HOESTDRANG, colour = as.factor(Kenmerk)), shape = 20, size = 2) +
geom_line(aes(x = VAS_DAY, y = HOESTDRANG, colour = as.factor(Kenmerk))) +
stat_smooth(aes(x = VAS_DAY, y = HOESTDRANG, group = 1), method = "loess", col = 1) +
theme_classic() +
theme(legend.position = "none")
# Add LOES smoother
p <-  ggplot(data = VAS_data_6) +
geom_point(aes(x = VAS_DAY, y = HOESTDRANG, colour = as.factor(Kenmerk)), shape = 20, size = 2) +
geom_line(aes(x = VAS_DAY, y = HOESTDRANG, colour = as.factor(Kenmerk))) +
stat_smooth(aes(x = VAS_DAY, y = HOESTDRANG, group = 1), method = "loess", col = 1, lwd = 2) +
theme_classic() +
theme(legend.position = "none")
p
ggsave("Y:/Onderzoek/Hurdle & Tobit/R/Plots/Spaghetti-LOESS.png")
##############################
## Step 4: Fit the Models   ##
##      HOESTDRANG          ##
#######################################
# Step 4C: Tweedie model  with cplm  ##
#######################################
library(cplm)
library(statmod)
cpglm.m1 <- cpglmm(HOESTDRANG ~ VAS_DAY +(VAS_DAY|Kenmerk),  data = VAS_data_6)
summary(cpglm.m1)
tt <- attr(cpglm.m1@model.frame,"terms")
Terms <- delete.response(tt)
X <- model.matrix(Terms, newdata, contrasts.arg = cpglm.m1@contrasts)
predictor <- as.numeric(X %*% beta)
mu <- as.vector(tweedie(link.power = cpglm.m1@link.power)$linkinv(predictor))
cpm.plotdata <- DF
cpm.plotdata$mu <- mu
DF <- with(VAS_data_6, expand.grid(VAS_DAY = seq(0, 168, length.out = 30) ))
X <- model.matrix(Terms, newdata = DF, contrasts.arg = cpglm.m1@contrasts)
tt <- attr(cpglm.m1@model.frame,"terms")
Terms <- delete.response(tt)
X <- model.matrix(Terms, newdata = DF, contrasts.arg = cpglm.m1@contrasts)
predictor <- as.numeric(X %*% beta)
Terms
DF
cpglm.m1@contrasts
model.matrix(Terms, newdata = DF, contrasts.arg = cpglm.m1@contrasts)
Terms <- delete.response(tt)
X <- model.matrix(Terms, newdata = DF, contrasts.arg = cpglm.m1@contrasts)
Terms
X <- model.matrix(Terms,  contrasts.arg = cpglm.m1@contrasts)
model.matrix
##############################
## Step 4: Fit the Models   ##
##      HOESTDRANG          ##
#######################################
# Step 4C: Tweedie model  with cplm  ##
#######################################
library(cplm)
library(statmod)
cpglm.m1 <- cpglmm(HOESTDRANG ~ VAS_DAY +(VAS_DAY|Kenmerk),  data = VAS_data_6)
DF <- with(VAS_data_6, expand.grid(VAS_DAY = seq(0, 168, length.out = 30) ))
summary(cpglm.m1)
tt <- attr(cpglm.m1@model.frame,"terms")
Terms <- delete.response(tt)
?`predict,cpglmm-method`
`predict,cpglmm-method`
predict.cpglmm-method
predict,cpglmm-method
X <- model.matrix(cpglm.m1)
predictor <- as.numeric(X %*% beta)
X
mu <- as.vector(tweedie(link.power = cpglm.m1@link.power)$linkinv(predictor))
predict.cpglmm-method
X <- model.matrix(cpglm.m1)
X
beta <- object@fixef
beta <- cpglm.m1@fixef
beta
predictor <- as.numeric(X %*% beta)
predictor
mu <- as.vector(tweedie(link.power = cpglm.m1@link.power)$linkinv(predictor))
cpm.plotdata <- DF
cpm.plotdata$mu <- mu
mu
X
X <- cbind(rep(1, nrow(DF)), DF)
beta <- cpglm.m1@fixef
predictor <- as.numeric(X %*% beta)
beta
X
names(X)
names(beta)
names(X) <- names(beta)
predictor <- as.numeric(X %*% beta)
X <- model.matrix(cpglm.m1)
X <- as.matrix(rep(1, nrow(DF)), DF)
X <- as.matrix(cbind(rep(1, nrow(DF)), DF))
X
predictor <- as.numeric(X %*% beta)
predictor <- as.numeric(X %*% beta)
mu <- as.vector(tweedie(link.power = cpglm.m1@link.power)$linkinv(predictor))
predict.cpglmm-method
cpm.plotdata <- DF
cpm.plotdata$mu <- mu
# make the effect plot together with the data
p <-  ggplot(data = VAS_data_6) +
geom_point(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk)), shape = 20, size = 2) +
geom_line(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk))) +
geom_line(data = cpm.plotdata, aes(x = VAS_DAY, y = exp(mu)), colour = "black",  lwd = 2) +
#geom_ribbon(data = plot_data, aes(x = VAS_DAY, ymin = exp(low), ymax = exp(upp)), fill = "black", alpha = 0.15) +
theme_classic() +
theme(legend.position = "none")
p
predict(cpglm.m1)
DF
predict(cpglm.m1, newdata = DF)
DF$Kenmerk <- "new"
predict(cpglm.m1, newdata = DF, ngrps = 1)
predict(cpglm.m1, newdata = DF)
predict(cpglm.m1, newdata = DF, flist = Kenmerk)
predict(cpglm.m1, newdata = DF, flist = DF$Kenmerk)
predict(cpglm.m1, newdata = DF, flist = DF$Kenmerk, ngrps = 1)
VAS_data_6
VAS_data_6$Kenmerk
VAS_data_6$Kenmerk[1]
DF$Kenmerk <- VAS_data_6$Kenmerk[1]
predict(cpglm.m1, newdata = DF, flist = DF$Kenmerk, ngrps = 1)
cpm.plotdata <- DF
# make the effect plot together with the data
p <-  ggplot(data = VAS_data_6) +
geom_point(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk)), shape = 20, size = 2) +
geom_line(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk))) +
geom_line(data = cpm.plotdata, aes(x = VAS_DAY, y = exp(mu)), colour = "black",  lwd = 2) +
geom_line(data = cpm.plotdata, aes(x = VAS_DAY, y = exp(mu_predict)), colour = "red",  lwd = 2) +
#geom_ribbon(data = plot_data, aes(x = VAS_DAY, ymin = exp(low), ymax = exp(upp)), fill = "black", alpha = 0.15) +
theme_classic() +
theme(legend.position = "none")
p
cpm.plotdata$mu_predict <- predict(cpglm.m1, newdata = DF, flist = DF$Kenmerk, ngrps = 1)
# make the effect plot together with the data
p <-  ggplot(data = VAS_data_6) +
geom_point(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk)), shape = 20, size = 2) +
geom_line(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk))) +
geom_line(data = cpm.plotdata, aes(x = VAS_DAY, y = exp(mu)), colour = "black",  lwd = 2) +
geom_line(data = cpm.plotdata, aes(x = VAS_DAY, y = exp(mu_predict)), colour = "red",  lwd = 2) +
#geom_ribbon(data = plot_data, aes(x = VAS_DAY, ymin = exp(low), ymax = exp(upp)), fill = "black", alpha = 0.15) +
theme_classic() +
theme(legend.position = "none")
p
DF$Kenmerk <- VAS_data_6$Kenmerk[1614]
cpm.plotdata$mu_predict <- predict(cpglm.m1, newdata = DF, flist = DF$Kenmerk, ngrps = 1)
# make the effect plot together with the data
p <-  ggplot(data = VAS_data_6) +
geom_point(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk)), shape = 20, size = 2) +
geom_line(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk))) +
geom_line(data = cpm.plotdata, aes(x = VAS_DAY, y = exp(mu)), colour = "black",  lwd = 2) +
geom_line(data = cpm.plotdata, aes(x = VAS_DAY, y = exp(mu_predict)), colour = "red",  lwd = 2) +
#geom_ribbon(data = plot_data, aes(x = VAS_DAY, ymin = exp(low), ymax = exp(upp)), fill = "black", alpha = 0.15) +
theme_classic() +
theme(legend.position = "none")
p
cpglm.m1
vcov(cpglm.m1)
V <- vcov(cpglm.m1)
ses <- sqrt(diag(X %*% V %*% t(X)))
ses
cpm.plotdata <- DF
cpm.plotdata$mu <- mu
cpm.plotdata$LO <- cpm.plotdata$mu - 1.96 * ses
cpm.plotdata$HI <- cpm.plotdata$mu + 1.96 * ses
# make the effect plot together with the data
p <-  ggplot(data = VAS_data_6) +
geom_point(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk)), shape = 20, size = 2) +
geom_line(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk))) +
geom_line(data = cpm.plotdata, aes(x = VAS_DAY, y = exp(mu)), colour = "black",  lwd = 2) +
geom_line(data = cpm.plotdata, aes(x = VAS_DAY, y = exp(mu_predict)), colour = "red",  lwd = 2) +
geom_ribbon(data = cpm.plotdata, aes(x = VAS_DAY, ymin = exp(LO), ymax = exp(HI)), fill = "black", alpha = 0.15) +
theme_classic() +
theme(legend.position = "none")
p
# The package cplm has a predict function, but this allows only predictions on patient levels:
# I need to fill in the random effect so I can only obtain patient specific predictions.
# See if we can find a way to fix this.
DF$Kenmerk <- VAS_data_6$Kenmerk[1614]
cpm.plotdata$mu_predict <- predict(cpglm.m1, newdata = DF, flist = DF$Kenmerk, ngrps = 1)
# make the effect plot together with the data
p <-  ggplot(data = VAS_data_6) +
geom_point(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk)), shape = 20, size = 2) +
geom_line(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk))) +
geom_line(data = cpm.plotdata, aes(x = VAS_DAY, y = exp(mu)), colour = "black",  lwd = 2) +
geom_line(data = cpm.plotdata, aes(x = VAS_DAY, y = exp(mu_predict)), colour = "red",  lwd = 2) +
geom_ribbon(data = cpm.plotdata, aes(x = VAS_DAY, ymin = exp(LO), ymax = exp(HI)), fill = "black", alpha = 0.15) +
theme_classic() +
theme(legend.position = "none")
p
# make the effect plot together with the data
p <-  ggplot(data = VAS_data_6) +
geom_point(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk)), shape = 20, size = 2) +
geom_line(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk))) +
geom_line(data = cpm.plotdata, aes(x = VAS_DAY, y = exp(mu)), colour = "black",  lwd = 2) +
#geom_line(data = cpm.plotdata, aes(x = VAS_DAY, y = exp(mu_predict)), colour = "red",  lwd = 2) +
geom_ribbon(data = cpm.plotdata, aes(x = VAS_DAY, ymin = exp(LO), ymax = exp(HI)), fill = "black", alpha = 0.15) +
theme_classic() +
theme(legend.position = "none")
p
ggsave("Y:/Onderzoek/Hurdle & Tobit/R/Plots/Spaghetti-cpglmm.png")
summary(cpglm.m1)
fit_zipoisson <- glmmTMB(HOESTDRANG ~ VAS_DAY+(VAS_DAY|Kenmerk),
data=VAS_data_6,
ziformula=~VAS_DAY,
family=poisson)
library(glmmTMB)
y <- VAS_data_6$HOESTDRANG
cens <- rep(0, nrow(VAS_data_6))
X <- cbind(rep(1, nrow(VAS_data_6)), VAS_data_6$VAS_DAY)
Z <- cbind(rep(1, nrow(VAS_data_6)), VAS_data_6$VAS_DAY)
cluster <- as.numeric(as.factor(VAS_data_6$Kenmerk))
tobit.m <-  lmec(yL = y, cens = cens, X = X, Z = Z, cluster = cluster,
method = 'ML', maxstep = 40)
summary(tobit.m)
# Library lmec for TOBIT with repeated measures
library(lmec)
y <- VAS_data_6$HOESTDRANG
cens <- rep(0, nrow(VAS_data_6))
X <- cbind(rep(1, nrow(VAS_data_6)), VAS_data_6$VAS_DAY)
Z <- cbind(rep(1, nrow(VAS_data_6)), VAS_data_6$VAS_DAY)
cluster <- as.numeric(as.factor(VAS_data_6$Kenmerk))
tobit.m <-  lmec(yL = y, cens = cens, X = X, Z = Z, cluster = cluster,
method = 'ML', maxstep = 40)
summary(tobit.m)
tobit.m
DF <- with(VAS_data_6, expand.grid(VAS_DAY = seq(0, 168, length.out = 30) ))
# I can calculate the predicted values manually by multiplying
# the beta coefficients with values for DAYS and taking the exp() of these values
X <- as.matrix(cbind(rep(1, nrow(DF)), DF))
X
tobit.m
beta <- tobit.m$beta
V <- tobit.m$varFix
ses <- sqrt(diag(X %*% V %*% t(X)))
predictor <- as.numeric(X %*% beta)
tobit.plotdata <- DF
tobit.plotdata$mu <- mu
tobit.plotdata$pred <- pred
tobit.plotdata$pred <- predictor
tobit.plotdata <- DF
tobit.plotdata$pred <- predictor
tobit.plotdata$LO <- tobit.plotdata$pred - 1.96 * ses
tobit.plotdata$HI <- tobit.plotdata$pred + 1.96 * ses
# make the effect plot together with the data
p <-  ggplot(data = VAS_data_6) +
geom_point(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk)), shape = 20, size = 2) +
geom_line(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk))) +
geom_line(data = tobit.plotdata, aes(x = VAS_DAY, y = pred), colour = "black",  lwd = 2) +
geom_ribbon(data = tobit.plotdata, aes(x = VAS_DAY, ymin = LO, ymax = HI), fill = "black", alpha = 0.15) +
theme_classic() +
theme(legend.position = "none")
p
ggsave("Y:/Onderzoek/Hurdle & Tobit/R/Plots/Spaghetti-tobit.png")
beta
V
str(tobit.m)
fit_zipoisson <- glmmTMB(HOESTDRANG ~ VAS_DAY+(VAS_DAY|Kenmerk),
data=VAS_data_6,
ziformula=~VAS_DAY,
family=poisson)
?family.glmmTMB
?family_glmmTMB
fit_glmmTMBtweedie <- glmmTMB(HOESTDRANG ~ VAS_DAY+(VAS_DAY|Kenmerk),
data=VAS_data_6,
ziformula=~VAS_DAY,
family=tweedie(link = "log"))
summary(fit_glmmTMBtweedie)
DF <- with(VAS_data_6, expand.grid(VAS_DAY = seq(0, 168, length.out = 30) ))
DF$Kenmerk <- "new"
pred <- predict(fit_zipoisson, newdata = DF, allow.new.levels = T, se.fit = T)
DF$pred <- pred$fit
# Get the lower and upper confidence intervals
DF$LO <- pred$fit - 1.96 * pred$se.fit
DF$HI <- pred$fit + 1.96 * pred$se.fit
# make the effect plot together with the data
p <-  ggplot(data = VAS_data_6) +
geom_point(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk)), shape = 20, size = 2) +
geom_line(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk))) +
geom_line(data = DF, aes(x = VAS_DAY, y = exp(pred)), colour = "black",  lwd = 2) +
#geom_ribbon(data = DF, aes(x = VAS_DAY, ymin = exp(LO), ymax = exp(HI)), fill = "black", alpha = 0.15) +
theme_classic() +
theme(legend.position = "none")
p
# make the effect plot together with the data
p <-  ggplot(data = VAS_data_6) +
geom_point(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk)), shape = 20, size = 2) +
geom_line(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk))) +
geom_line(data = DF, aes(x = VAS_DAY, y = exp(pred)), colour = "black",  lwd = 2) +
geom_ribbon(data = DF, aes(x = VAS_DAY, ymin = exp(LO), ymax = exp(HI)), fill = "black", alpha = 0.15) +
theme_classic() +
theme(legend.position = "none")
p
pred <- predict(fit_glmmTMBtweedie, newdata = DF, allow.new.levels = T, se.fit = T)
DF$pred <- pred$fit
# Get the lower and upper confidence intervals
DF$LO <- pred$fit - 1.96 * pred$se.fit
DF$HI <- pred$fit + 1.96 * pred$se.fit
# make the effect plot together with the data
p <-  ggplot(data = VAS_data_6) +
geom_point(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk)), shape = 20, size = 2) +
geom_line(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk))) +
geom_line(data = DF, aes(x = VAS_DAY, y = exp(pred)), colour = "black",  lwd = 2) +
geom_ribbon(data = DF, aes(x = VAS_DAY, ymin = exp(LO), ymax = exp(HI)), fill = "black", alpha = 0.15) +
theme_classic() +
theme(legend.position = "none")
p
fit_glmmTMBtweedie
fit_glmmTMBtweedie <- glmmTMB(HOESTDRANG ~ VAS_DAY+(VAS_DAY|Kenmerk),
data=VAS_data_6,
family=tweedie(link = "log"))
summary(fit_glmmTMBtweedie)
DF <- with(VAS_data_6, expand.grid(VAS_DAY = seq(0, 168, length.out = 30) ))
DF$Kenmerk <- "new"
pred <- predict(fit_glmmTMBtweedie, newdata = DF, allow.new.levels = T, se.fit = T)
DF$pred <- pred$fit
# Get the lower and upper confidence intervals
DF$LO <- pred$fit - 1.96 * pred$se.fit
DF$HI <- pred$fit + 1.96 * pred$se.fit
# make the effect plot together with the data
p <-  ggplot(data = VAS_data_6) +
geom_point(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk)), shape = 20, size = 2) +
geom_line(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk))) +
geom_line(data = DF, aes(x = VAS_DAY, y = exp(pred)), colour = "black",  lwd = 2) +
geom_ribbon(data = DF, aes(x = VAS_DAY, ymin = exp(LO), ymax = exp(HI)), fill = "black", alpha = 0.15) +
theme_classic() +
theme(legend.position = "none")
p
DF <- with(VAS_data_6, expand.grid(VAS_DAY = seq(0, 168, length.out = 30) ))
DF$Kenmerk <- "new"
pred <- predict(fit_glmmTMBtweedie, newdata = DF, allow.new.levels = T, se.fit = T)
DF$pred <- pred$fit
# Get the lower and upper confidence intervals
DF$LO <- pred$fit - 1.96 * pred$se.fit
DF$HI <- pred$fit + 1.96 * pred$se.fit
# make the effect plot together with the data
p <-  ggplot(data = VAS_data_6) +
geom_point(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk)), shape = 20, size = 2) +
geom_line(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk))) +
geom_line(data = DF, aes(x = VAS_DAY, y = exp(pred)), colour = "black",  lwd = 2) +
#geom_ribbon(data = DF, aes(x = VAS_DAY, ymin = exp(LO), ymax = exp(HI)), fill = "black", alpha = 0.15) +
theme_classic() +
theme(legend.position = "none")
p
fit_glmmTMBtweedie <- glmmTMB(HOESTDRANG ~ VAS_DAY+(VAS_DAY|Kenmerk),
data = VAS_data_6,
family = tweedie())
summary(fit_glmmTMBtweedie)
DF <- with(VAS_data_6, expand.grid(VAS_DAY = seq(0, 168, length.out = 30) ))
DF$Kenmerk <- "new"
pred <- predict(fit_glmmTMBtweedie, newdata = DF, allow.new.levels = T, se.fit = T)
DF$pred <- pred$fit
# Get the lower and upper confidence intervals
DF$LO <- pred$fit - 1.96 * pred$se.fit
DF$HI <- pred$fit + 1.96 * pred$se.fit
# make the effect plot together with the data
p <-  ggplot(data = VAS_data_6) +
geom_point(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk)), shape = 20, size = 2) +
geom_line(aes(x = VAS_DAY, y = jitter(HOESTDRANG), colour = as.factor(Kenmerk))) +
geom_line(data = DF, aes(x = VAS_DAY, y = exp(pred)), colour = "black",  lwd = 2) +
#geom_ribbon(data = DF, aes(x = VAS_DAY, ymin = exp(LO), ymax = exp(HI)), fill = "black", alpha = 0.15) +
theme_classic() +
theme(legend.position = "none")
p
knitr::opts_chunk$set(echo = TRUE)
class(v)
warnings()
library(readxl)
library(lme4)
library(GLMMadaptive)
library(ggplot2)
library(dplyr)
VAS_data <- read_excel("Y:/Long/Gizal Nakshbandi/VAS_Totaal_final.xls")
# Bereken hoeveel patienten er in de data zitten voor een longitudinale data set
sapply(VAS_data, function(x) length(unique(VAS_data$Kenmerk)))
# Use only the first half year (DAY < 169)
VAS_data_6 <- VAS_data %>% filter(VAS_DAY < 169)
summary(VAS_data_6$VAS_DAY)
p <-  ggplot(data = VAS_data_6) +
geom_point(aes(x = VAS_DAY, y = HOESTDRANG, colour = as.factor(Kenmerk)), shape = 20, size = 2) +
geom_line(aes(x = VAS_DAY, y = HOESTDRANG, colour = as.factor(Kenmerk))) +
theme_classic() +
theme(legend.position = "none")
p
# Library lmec for TOBIT with repeated measures
library(lmec)
y <- VAS_data_6$HOESTDRANG
cens <- rep(0, nrow(VAS_data_6))
X <- cbind(rep(1, nrow(VAS_data_6)), VAS_data_6$VAS_DAY)
Z <- cbind(rep(1, nrow(VAS_data_6)), VAS_data_6$VAS_DAY)
cluster <- as.numeric(as.factor(VAS_data_6$Kenmerk))
tobit.m <-  lmec(yL = y, cens = cens, X = X, Z = Z, cluster = cluster,
method = 'ML', maxstep = 40)
summary(tobit.m)
tobit.m$bi
summary(tobit.m)
tobit.m$Psi
# Cannot find repeated measures yet
library(VGAM)
tobit.m <- vglm(HOESTDRANG ~ VAS_DAY , tobit(Lower = 0, Upper = 10),  data = VAS_Totaal_final)
View(VAS_data_6)
tobit.m <- vglm(HOESTDRANG ~ VAS_DAY , tobit(Lower = 0, Upper = 10),  data = VAS_data_6)
summary(tobit.m)
tobit.m$beta
summary(tobit.m)
tobit.m1 <- vglm(HOESTDRANG ~ VAS_DAY , tobit(Lower = 0, Upper = 10),  data = VAS_data_6)
y <- VAS_data_6$HOESTDRANG
cens <- rep(0, nrow(VAS_data_6))
X <- cbind(rep(1, nrow(VAS_data_6)), VAS_data_6$VAS_DAY)
Z <- cbind(rep(1, nrow(VAS_data_6)), VAS_data_6$VAS_DAY)
cluster <- as.numeric(as.factor(VAS_data_6$Kenmerk))
tobit.m <-  lmec(yL = y, cens = cens, X = X, Z = Z, cluster = cluster,
method = 'ML', maxstep = 40)
summary(tobit.m1)
tobit.m$beta
